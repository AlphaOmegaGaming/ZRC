scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils
library NonfungibleToken

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let one = Uint256 1

(* Check if a sender is an operator of the owner, approved for the given ID *)
(* or is the owner of the token                                             *)
let isApprovedOrOwner =
  fun (isOwner: Bool) =>
  fun (isApproved: Bool) =>
  fun (isApprovedForAll: Bool) =>
    let isOwnerOrApproved =  orb isOwner isApproved in
    orb isOwnerOrApproved isApprovedForAll

(* Error events *)
type Error =
  | CodeNotAuthorized
  | CodeNotFound
  | CodeTokenExists
  | CodeUnexpectedError
  | CodeNotValid

let makeErrorEvent =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeNotAuthorized    => Int32 -1
      | CodeNotFound         => Int32 -2
      | CodeTokenExists      => Int32 -3
      | CodeUnexpectedError  => Int32 -4
      | CodeNotValid         => Int32 -5
      end
    in
    { _eventname : "Error"; code : result_code }

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract NonfungibleToken
(contractOwner: ByStr20,
  name : String,
  symbol: String
)

(* Mutable fields *)

(* Mapping between tokenId to token owner *)
field tokenOwners: Map Uint256 ByStr20 = Emp Uint256 ByStr20

(* Mapping from owner to number of owned tokens *)
field ownedTokenCount: Map ByStr20 Uint256 = Emp ByStr20 Uint256

(* Mapping between tokenId to approved address *)
(* @dev: There can only be one approved address per token at any given time. *)
field tokenApprovals: Map Uint256 ByStr20 = Emp Uint256 ByStr20

(* Mapping from owner to operator approvals  *)
field operatorApprovals: Map ByStr20 (Map ByStr20 Bool)
                            = Emp ByStr20 (Map ByStr20 Bool)

(* Emit Errors *)
procedure MakeError(err : Error)
  e = makeErrorEvent err;
  event e
end

(* @notice: Count all NFTs assigned to a tokenOwner *)
transition balanceOf(address: ByStr20) 
  optionBal <- ownedTokenCount[address];
  balance = 
    match optionBal with
    | Some bal => bal
    | None => Uint256 0
    end;
  e = {_eventname: "BalanceOfSuccess"; bal: balance};
  event e
end

(* @dev:    Mint new tokens. Only contractOwner can mint. *)
(* @param:  to      - Address of the token recipient      *)
(* @param:  tokenId - ID of the new token minted          *)
(* Returns error message CodeTokenExists if token exists  *)
transition mint(to: ByStr20, tokenId: Uint256)
  (* Check if token exists *)
  tokenExist <- exists tokenOwners[tokenId];
  match tokenExist with
  | True =>
    (* Token exists, return error code *)
    err = CodeTokenExists;
    MakeError err
  | False =>
    (* Prevent transferring of NFT to _this_address *)
    isContractAddress = builtin eq to _this_address;
    match isContractAddress with
    | False =>
      (* Check if sender is contractOwner *)
      isContractOwner = builtin eq _sender contractOwner;
      match isContractOwner with
      | True =>
        (* Mint new token *)
        tokenOwners[tokenId] := to;
        (* Add to owner's count *)
        userCount <- ownedTokenCount[to];
        match userCount with
        | Some val =>
          (* Append to existing results *)
          val = builtin add val one;
          ownedTokenCount[to] := val
        | None => 
          ownedTokenCount[to] := one
        end;
        (* Emit success event *)
        e = {_eventname: "MintSuccess"; by: _sender; recipient: to; token: tokenId};
        event e
      | False =>
        (* Unauthorized transaction*)
        err = CodeNotAuthorized;
        MakeError err
      end
    | True =>
      err = CodeNotValid;
      MakeError err
    end
  end
end

(* @dev:    Burn existing tokens. Only tokenOwner or approved Operator can burn a token *)
(* @param:  tokenId - ID of the new token destroyed                                     *)
(* Returns error message CodeNotFound if token does not exists                          *)
transition burn(tokenId: Uint256)
  (* Check if token exists *)
  getTokenOwner <- tokenOwners[tokenId];
  match getTokenOwner with
  | None =>
    (* Token do not exists, return error code *)
    err = CodeNotFound;
    MakeError err
  | Some tokenOwner =>
    (* Check if sender is tokenOwner *)
    isOwner = builtin eq _sender tokenOwner;
    (* Check if sender is tokenOwner approvedForAll operator *)
    getOperator <- operatorApprovals[tokenOwner][_sender];
    isApprovedForAll = match getOperator with
      | None => False
      | Some val => val
      end;
    (* Check if sender is an authorised personnel *)
    isAuthorised = orb isOwner isApprovedForAll;
    match isAuthorised with
    | False =>
      (* Unauthorized transaction *)
      err = CodeNotAuthorized;
      MakeError err
    | True =>
      (* Destroy existing token *)
      delete tokenOwners[tokenId];
      delete tokenApprovals[tokenId];
      (* Deduct from token owner count *)
      userCount <- ownedTokenCount[tokenOwner];
      match userCount with
      | Some val =>
        (* Deduct existing value *)
        val = builtin sub val one;
        ownedTokenCount[tokenOwner] := val
      | None =>
        err = CodeUnexpectedError;
        MakeError err
      end;
      (* Emit success event *)
      e = {_eventname: "BurnSuccess"; by: _sender; token: tokenId};
      event e
    end
  end
end

(* @dev: Transfer the ownership of a given tokenId to another address *)
(* @param: to      - Recipient address for the token                  *)
(* @param: tokenId - ID of the token to be transferred                *)
transition transfer(to: ByStr20, tokenId: Uint256)
  (* Prevent transferring of NFT to _this_address *)
  isContractAddress = builtin eq to _this_address;
  match isContractAddress with
  | False =>
    (* Check if token exists *)
    getTokenOwner <- tokenOwners[tokenId];
    match getTokenOwner with
    | None =>
      (* Token do not exists, return error code *)
      err = CodeNotFound;
      MakeError err
    | Some tokenOwner =>
      (* Check if sender is tokenOwner *)
      isOwner = builtin eq _sender tokenOwner;
      getTokenApproval <- tokenApprovals[tokenId];
      isApproved = match getTokenApproval with
        | None => False
        | Some approvedAddress => 
          (* Check if sender is an approved address *)
          builtin eq _sender approvedAddress
        end;
      (* Check if sender is tokenOwner approvedForAll operator *)
      getOperatorStatus <- operatorApprovals[tokenOwner][_sender];
      isApprovedForAll = match getOperatorStatus with
        | None => False
        | Some val => val
        end;
      (* Check if sender is an authorised personnel *)
      isAuthorised = isApprovedOrOwner isOwner isApproved isApprovedForAll;
      match isAuthorised with
      | False =>
        (* Unauthorized transaction*)
        err = CodeNotAuthorized;
        MakeError err
      | True =>
        (* Change tokenOwner for that tokenId *)
        tokenOwners[tokenId] := to;
        (* Delete tokenApproval entry for that tokenId *)
        delete tokenApprovals[tokenId];
        (* Subtract one from previous token owner's count *)
        someFromBal <- ownedTokenCount[tokenOwner];
        match someFromBal with
        | Some fromBal =>
          fromBal = builtin sub fromBal one;
          ownedTokenCount[tokenOwner] := fromBal
        | None => 
          err = CodeUnexpectedError;
          MakeError err
        end;
        (* Add one to the new token owner's count *)
        someToBal <- ownedTokenCount[to];
        match someToBal with
        | Some toBal =>
          toBal = builtin add toBal one;
          ownedTokenCount[tokenOwner] := toBal
        | None => ownedTokenCount[tokenOwner] := one
        end;
        e = {_eventname: "TransferSuccess"; from: _sender; recipient: to; token: tokenId};
        event e
      end
    end
  | True =>
    err = CodeNotValid;
    MakeError err
  end
end

(* @dev: Approves another address the ability to transfer the given tokenId *)
(* There can only be one approved address per token at a given time         *)
(* Absence of entry in tokenApproval indicates there is no approved address *)
(* param: to      - Address to be approved for the given tokenId            *)
(* param: tokenId - ID of the token to be approved                          *)
transition approve(to: ByStr20, tokenId: Uint256)
  (* Get tokenOwner address *)
  getTokenOwner <- tokenOwners[tokenId];
  match getTokenOwner with
  | None =>
    (* Token not found *)
    err = CodeNotFound;
    MakeError err
  | Some tokenOwner =>
    isOwner = builtin eq _sender tokenOwner;
    getApprovedForAll <- operatorApprovals[tokenOwner][_sender];
    isApprovedForAll = match getApprovedForAll with
      | Some val => val
      | None => False
      end;
    isAuthorized = orb isOwner isApprovedForAll;
    match isAuthorized with
    | True =>
      (* Add to tokenApproval mapping *)
      tokenApprovals[tokenId] := to;
      (* Emit event *)
      e = {_eventname: "ApproveSuccess"; from: _sender; approvedTo: to; token: tokenId};
      event e
    | False =>
      (* Unauthorized transaction *)
      err = CodeNotAuthorized;
      MakeError err
    end
  end
end

(* @dev: Sets or unsets the approval of a given operator           *)
(* @param: to       - Address to be set or unset as operator       *)
(* @param: approved - Status of approval to be set for the address *)
transition setApprovalForAll(to: ByStr20, approved: Bool)
  (* Checks if the _sender is approving himself *)
  isValidOperation = let check = builtin eq _sender to in negb check;
  (* Require the approval to not be the _sender *)
  match isValidOperation with
  | True =>
    (* Check if _sender has an existing record on the operatorApproval *)
    operatorApprovals[_sender][to] := approved;
    (* Stringify boolean value to be emitted in the event *)
    approvedStr = bool_to_string approved;
    e = {_eventname: "SetApprovalForAllSuccess"; by: _sender; recipient: to; status: approvedStr};
    event e
  | False =>
    err = CodeNotAuthorized;
    MakeError err
  end
end